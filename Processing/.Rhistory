coeff = extract_numeric(model_vac_bad$coefficients[2])
coeff[2] = extract_numeric(model_vac_ob$coefficients[2])
coeff[3] = extract_numeric(model_worry$coefficients[2])
coeff[4] = extract_numeric(model_risk$coefficients[2])
coeff[5] = extract_numeric(model_conspiracy$coefficients[2])
coeff[6] = extract_numeric(model_nat$coefficients[2])
coeff[7] = extract_numeric(model_h_locus$coefficients[2])
coeff[8] = extract_numeric(model_he_eco$coefficients[2])
coeff[9] = extract_numeric(model_PTV_L$coefficients[2])
coeff[10] = extract_numeric(model_PTV_5SM$coefficients[2])
coeff[11] = extract_numeric(model_PTV_BOI$coefficients[2])
coeff[12] = extract_numeric(model_tr_sci$coefficients[2])
coeff[13] = extract_numeric(model_pray$coefficients[2])
coeff[14] = extract_numeric(model_media$coefficients[2])
coeff[15] = extract_numeric(model_low_comp$coefficients[2])
coeff[16] = extract_numeric(model_distrust_gov$coefficients[2])
coeff[17] = extract_numeric(model_distrust_inst$coefficients[2])
#Transform in odds ratio
coeff_exp = unlist(lapply(coeff, exp))
#Significance
summary(model_vac_bad)$coeff[-1,4] < 0.05
summary(model_vac_ob)$coeff[-1,4] < 0.05
summary(model_worry)$coeff[-1,4] < 0.05 #not significant
summary(model_risk)$coeff[-1,4] < 0.05
summary(model_conspiracy)$coeff[-1,4] < 0.05
summary(model_nat)$coeff[-1,4] < 0.05
summary(model_h_locus)$coeff[-1,4] < 0.05
summary(model_he_eco)$coeff[-1,4] < 0.05
summary(model_PTV_L)$coeff[-1,4] < 0.05
summary(model_PTV_5SM)$coeff[-1,4] < 0.05 #not significant
summary(model_PTV_BOI)$coeff[-1,4] < 0.05
summary(model_tr_sci)$coeff[-1,4] < 0.05
summary(model_pray)$coeff[-1,4] < 0.05 #not significant
summary(model_media)$coeff[-1,4] < 0.05 #not significant
summary(model_low_comp)$coeff[-1,4] < 0.05
summary(model_distrust_gov)$coeff[-1,4] < 0.05
summary(model_distrust_inst)$coeff[-1,4] < 0.05
#vector for significance
Significance = rep(c("Significant"),17)
Significance[3] = "Not significant"
Significance[10] = "Not significant"
Significance[13] = "Not significant"
Significance[14] = "Not significant"
#Gatering strength scores
strength = centMGM %>%
filter(measure=="Strength") %>%
dplyr::select(value) %>%
filter(!row_number() %in% c(15:20))
cent_all = centMGM %>%
filter(measure=="Strength") %>%
dplyr::select(value, node) %>%
mutate_if(is.numeric, ~round(., 2))
#Gatering degree
degree_cent_graph = degree_cent[-c(15:20)]
#Gathering names
names = shortnames
names = names[-c(15:20)]
#Merging into a df1 (Reported in Supplement S1)
scatterplot = data.frame(names, coeff_exp, strength, Significance) %>%
rename(strength = value)
scatterplot$names = as.factor(scatterplot$names)
scatterplot$coeff_exp = as.numeric(scatterplot$coeff_exp)
scatterplot$strength = as.numeric(scatterplot$strength)
scatterplot$Significance = as.factor(scatterplot$Significance)
#Merging into a df2
scatterplot_degree = data.frame(names, coeff_exp, degree_cent_graph, Significance)
scatterplot_degree$degree_cent_graph = as.numeric(scatterplot_degree$degree_cent_graph)
print(scatterplot_degree)
#Strength (Article)
graph_strength = ggplot(scatterplot, aes(x=strength, y=coeff_exp, label = names)) +
geom_point((aes(color=Significance))) + theme_nice() +
geom_smooth(method=lm, se = FALSE, linetype = "dotted", color = "#DCDCDC") +
geom_text_repel(size = 3) +
xlab("Strength centrality") + ylab("Regression coefficient") +
scale_fill_discrete(labels=c('label1', 'label2'))
ggsave(here("Output", "Article", "graph_strength.jpg"), graph_strength, height = 5, width = 8)
#Degree (Supplement S1)
graph_degree = ggplot(scatterplot_degree, aes(x=degree_cent_graph, y=coeff_exp, label = names)) +
geom_point((aes(color=Significance))) + theme_nice() +
geom_smooth(method=lm, se = FALSE, linetype = "dotted", color = "#DCDCDC") +
geom_text_repel(size = 3) +
xlab("Degree centrality") + ylab("Regression coefficient") +
scale_fill_discrete(labels=c('label1', 'label2'))
ggsave(here("Output", "Supplement", "graph_degree.jpg"), graph_degree, height = 5, width = 8)
#Df with variables that (1) are tied to hesitancy, (2) are in the backbone
final_tab = scatterplot %>%
mutate(degree = scatterplot_degree$degree_cent_graph) %>%
add_row(names = "educ", coeff_exp = 1.764246, strength = 1.061313041,
Significance = "Significant", degree = 10) %>%
filter(names %in% c("vac_free","vac_bad","low_comp","conspiracy","nat","educ")) %>%
mutate(edge_weight=c(0.95, 0.34, 0.34, 0.12, 0.07, 0.07)) %>%
relocate(Significance, .after = edge_weight)
#conversion of type
final_tab$names = as.factor(final_tab$names)
final_tab$coeff_exp = as.numeric(final_tab$coeff_exp)
final_tab$strength = as.numeric(final_tab$strength)
final_tab$degree = as.numeric(final_tab$degree)
final_tab$edge_weight = as.numeric(final_tab$edge_weight)
final_tab$Significance = as.factor(final_tab$Significance)
#Z scores
final_tab_z = final_tab %>%
mutate(coeff_exp = (coeff_exp - mean(coeff_exp))/sd(coeff_exp),
strength = (strength - mean(strength))/sd(strength),
degree = (degree - mean(degree))/sd(degree),
edge_weight = (edge_weight - mean(edge_weight))/sd(edge_weight)) %>%
mutate_if(is.numeric, ~round(., 2))
#communities
saveRDS(CommunityStabTotal, here("Input", "CommunityStabTotal.rds"))
#bootnet
saveRDS(edgeacc, here("Input","edgeacc.rds"))
saveRDS(centstab, here("Input", "centstab.rds"))
#final tab
saveRDS(final_tab, here("Input", "final_tab.rds"))
saveRDS(final_tab_z, here("Input", "final_tab_z.rds"))
##only upper triangle without edge weigths 0 for readability
EdgeWeight_Total_half<-upper.triangle(inputGraphMGM)
EdgeWeight_Total_half[EdgeWeight_Total_half == 0] <- NA
EdgeWeightsExcel_half<- list("mgm" = EdgeWeight_Total_half)
write.xlsx(EdgeWeightsExcel_half, "../Output/Supplement/EdgeWeightsExcel_half.xlsx",
colWidths = "auto", rowNames = TRUE)
#packages
library("pacman")
p_load(tidyverse, here, sjlabelled, stringr, glue, janitor, haven, stargazer,
ltm, skimr, readxl)
#remove scientific notation
options(scipen=999)
#Load database
response_original = read_rds(here("Input", "v1.0_ResPOnsE_COVID_19_W1-W4-2.rds"))  %>%
clean_names()
# 10 November to 22 December 2021
#Select and rename variables
W3 = response_original %>%
filter(info_wave==3) %>%
dplyr::select(c(v2,v3,j5_01,v1,f10,f3,f9,h1_04,j4bis_b,b2_03,b2_06,b2_07,d5,d1,
e4_bis,k3_03,k3_04,k3_05,e2_01,e2_04,j5_02,g7,c5,s1,s2,
s9,s8,c1)) %>%
mutate(across(v2:c1, ~replace(., .>97 , NA))) %>%
na.omit()
#colnames
colnames(W3) = c("vac","vac_int","vac_bad","vac_ob","worry","risk","conspiracy",
"nat","h_locus","comp_dist", "comp_mask","comp_hand","he_eco",
"judg_gov_covid","judg_gov","PTV_L","PTV_5SM","PTV_BOI","tr_par",
"tr_EU","tr_sci","pray","media","sex","age","educ",
"reg","eco_insec")
#combine vac_int and vac in INT_VAC
W3 = W3 %>%
mutate(hesitancy = case_when(
(vac_int < 3  | vac == 1)~ 0,
(vac_int > 2 & vac == 2)~ 1,)) %>%
dplyr::select(-c(vac_int, vac))
#invert polarity and recode
W3 = W3 %>%
mutate((across(vac_bad,  ~ 6 - .)),
worry = ifelse(worry<=2, 1, 0),
conspiracy = ifelse(conspiracy<3, 1, 0),
pray = ifelse(pray<=4, 0, 1),
media = ifelse(media>=4 & media<=7, 1, 0),
sex = ifelse(sex==2, 1, 0),
educ = ifelse(educ<=5, 1, 0),
(across(age,  ~ 89 - .)),
reg = ifelse(reg<=3, 1, 0),
(across(comp_dist:comp_hand,  ~ 10 - .)),
(across(judg_gov_covid:judg_gov,  ~ 10 - .)),
(across(tr_par:tr_EU,  ~ 10- .)))
#Load valid cases spreadshit (avaiable at: https://dataverse.unimi.it/dataset.xhtml?persistentId=doi:10.13130/RD_UNIMI/FF0ABQ)
valid = read_excel(here("Input", "Valid_cases.xlsx"))
#Select V I used in the analysis to retrieve true number of N
valid = valid %>%
dplyr::select(c(v2,v3,j5_01,v1,f10,f3,f9,h1_04,j4bis_b,b2_03,b2_06,b2_07,d5,d1,
e4_bis,k3_03,k3_04,k3_05,e2_01,e2_04,j5_02,g7,c5,s1,s2,
s9,s8,c1))
#Extract miniumu number of obs per question
min(valid)
# TRUE N = 3767. Thus I had 3767 before listwise, 1535 after. It means I m working with 40.7% of
# the original sample.
#PCA
#compliance
compliance = data.frame(W3$comp_mask, W3$comp_hand, W3$comp_dist)
compliance = na.omit(compliance)
pr_compliance <- princomp(na.omit(compliance), cor = TRUE)
W3$low_comp = apply(W3[8:10], 1, mean, na.rm = TRUE)
W3 = W3 %>%
dplyr::select(-c(comp_hand, comp_mask, comp_dist))
#Gov
gov = data.frame(W3$judg_gov_covid, W3$judg_gov)
gov = na.omit(gov)
pr_gov <- princomp(na.omit(gov), cor = TRUE)
W3$distrust_gov = apply(W3[9:10], 1, mean, na.rm = TRUE)
W3 = W3 %>%
dplyr::select(-c(judg_gov_covid, judg_gov))
#inst_tr (excluded from core)
inst_tr = data.frame(W3$tr_par, W3$tr_EU)
inst_tr = na.omit(inst_tr)
pr_inst_tr <- princomp(na.omit(inst_tr), cor = TRUE)
W3$distrust_inst = apply(W3[12:13], 1, mean, na.rm = TRUE)
W3 = W3 %>%
dplyr::select(-c(tr_par, tr_EU))
summary_vaccine  = as.data.frame(skim(W3))
stargazer(as.data.frame(W3), type = "text", nobs = TRUE)
#dimensionality
pr_compliance #unidimensional
pr_gov #unidimensional
pr_inst_tr #unidimensional
#alphas
cronbach.alpha(compliance, CI=TRUE, standardized=TRUE)
cronbach.alpha(gov, CI=TRUE, standardized=TRUE)
cronbach.alpha(inst_tr, CI=TRUE, standardized=TRUE)
#export data
saveRDS(W3, here("Input", "W3.rds"))
# TRUE N = 3767. Thus I had 3767 before listwise, 1535 after. It means I m working with 40.7% of
# the original sample.
valid
knitr::opts_chunk$set(echo = TRUE)
library(pacman)
p_load(tidyverse, here, sjlabelled, stringr, glue, EGAnet, janitor, haven,
ggpubr, gridExtra, dplyr, GGally, qgraph, sjmisc, igraph, sjPlot,
grid, psych, stargazer, mgm, backbone, ggplot2, tnet, ggrepel,
NetworkComparisonTest, Matrix, bootnet, matrixcalc, openxlsx, devtools, jtools)
W3 = readRDS((here("Input", "W3.rds")))
## network objects
type <-c("g","g","c","g","c","g","g","g","g","g","g","g","c","c","c","g","c",
"c","g","c","g","g","g")
level <-c("1","1","2","1","2","1","1","1","1","1","1","1","2","2","2","1","2"
,"2","1","2","1","1","1")
shortnames <- c(
"vac_bad",
"vac_free",
"low_worry",
"low_risk",
"conspiracy",
"nat",
"int_locus",
"low_col_resp",
"PTV_L",
"PTV_5SM",
"PTV_BOI",
"distrust_sci",
"pray",
"media",
"female",
"young",
"low_educ",
"rural",
"eco_insec",
"hesitancy",
"low_comp",
"distrust_gov",
"distrust_inst")
longnames <- c(
"Vaccine bad for health",
"Against mandatory vaccination",
"Low worry about infection",
"Low risk perception",
"Endorsing conspiracy theories",
"Trust in alternative medicine",
"Internal health locus of control",
"Low sense of collective responsability",
"Propensity to vote for L",
"Propensity to vote for 5SM",
"Propensity to vote for BOI",
"Distrust of science",
"Religion, pray",
"Digital media diet",
"Sex, female",
"Age, young",
"Educational level, low",
"Living in a rural region",
"Economic insecurity",
"Vaccine hesitancy",
"Low compliance with preventive behaviors",
"Disapproval of Government",
"Distrust of institutions")
shapes <- c(
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"square",
"circle",
"circle",
"circle")
# Community detection function (modified to allow for iterations)
communityStability <- function(data, type, level, iterations)
{
communityMemberships <- list()
for (i in 1:iterations)
{
fitGraph <- mgm(data, type, level, k = 2, verbatim = TRUE)
iGraph<- graph_from_adjacency_matrix(abs
(fitGraph$pairwise$wadj), "undirected", weighted =
TRUE)
communityMemberships[[i]] <- cluster_walktrap(iGraph)$membership
}
communityOverlap <- matrix(NA, length(data), length(data))
for(j in 1:length(data))
{
overlapPerNode <- matrix(NA, iterations, ncol(communityOverlap))
for(k in 1: iterations)
{
overlapPerNode[k,] <- as.numeric(communityMemberships[[k]][j] == communityMemberships[[k]])
}
communityOverlap[j,] <- apply(overlapPerNode, 2, mean)
}
diag(communityOverlap) <- 0
return(list(communityMemberships = communityMemberships, communityOverlap = communityOverlap))
}
set.seed(1)
FitW3 <- mgm(W3, type, level, k = 2, binarySign = TRUE)
CommunityStabTotal<-communityStability(W3, type, level, it=1000)
knitr::opts_chunk$set(echo = TRUE)
library(pacman)
p_load(tidyverse, here, sjlabelled, stringr, glue, EGAnet, janitor, haven,
ggpubr, gridExtra, dplyr, GGally, qgraph, sjmisc, igraph, sjPlot,
grid, psych, stargazer, mgm, backbone, ggplot2, tnet, ggrepel,
NetworkComparisonTest, Matrix, bootnet, matrixcalc, openxlsx, devtools, jtools)
W3 = readRDS((here("Input", "W3.rds")))
## network objects
type <-c("g","g","c","g","c","g","g","g","g","g","g","g","c","c","c","g","c",
"c","g","c","g","g","g")
level <-c("1","1","2","1","2","1","1","1","1","1","1","1","2","2","2","1","2"
,"2","1","2","1","1","1")
shortnames <- c(
"vac_bad",
"vac_free",
"low_worry",
"low_risk",
"conspiracy",
"nat",
"int_locus",
"low_col_resp",
"PTV_L",
"PTV_5SM",
"PTV_BOI",
"distrust_sci",
"pray",
"media",
"female",
"young",
"low_educ",
"rural",
"eco_insec",
"hesitancy",
"low_comp",
"distrust_gov",
"distrust_inst")
longnames <- c(
"Vaccine bad for health",
"Against mandatory vaccination",
"Low worry about infection",
"Low risk perception",
"Endorsing conspiracy theories",
"Trust in alternative medicine",
"Internal health locus of control",
"Low sense of collective responsability",
"Propensity to vote for L",
"Propensity to vote for 5SM",
"Propensity to vote for BOI",
"Distrust of science",
"Religion, pray",
"Digital media diet",
"Sex, female",
"Age, young",
"Educational level, low",
"Living in a rural region",
"Economic insecurity",
"Vaccine hesitancy",
"Low compliance with preventive behaviors",
"Disapproval of Government",
"Distrust of institutions")
shapes <- c(
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"circle",
"square",
"circle",
"circle",
"circle")
# Community detection function (modified to allow for iterations)
communityStability <- function(data, type, level, iterations)
{
communityMemberships <- list()
for (i in 1:iterations)
{
fitGraph <- mgm(data, type, level, k = 2, verbatim = TRUE)
iGraph<- graph_from_adjacency_matrix(abs
(fitGraph$pairwise$wadj), "undirected", weighted =
TRUE)
communityMemberships[[i]] <- cluster_walktrap(iGraph)$membership
}
communityOverlap <- matrix(NA, length(data), length(data))
for(j in 1:length(data))
{
overlapPerNode <- matrix(NA, iterations, ncol(communityOverlap))
for(k in 1: iterations)
{
overlapPerNode[k,] <- as.numeric(communityMemberships[[k]][j] == communityMemberships[[k]])
}
communityOverlap[j,] <- apply(overlapPerNode, 2, mean)
}
diag(communityOverlap) <- 0
return(list(communityMemberships = communityMemberships, communityOverlap = communityOverlap))
}
set.seed(1)
FitW3 <- mgm(W3, type, level, k = 2, binarySign = TRUE)
#LOAD THE OBJECT down below TO SAVE TIME:
CommunityStabTotal<-communityStability(W3, type, level, it=1000)
#load the object instead:
CommunityStabTotal = readRDS(here("Input", "CommunityStabTotal.rds"))
# Visualize community stability
pdf(file = '../Output/Supplement/community_stability.pdf',paper = "USr",
height = 9, width = 12)
qgraph(CommunityStabTotal$communityOverlap, layout = "spring",
theme = "Borkulo", labels = shortnames,
nodeNames = longnames,vsize=4.0,
edge.labels=FALSE, legend = TRUE, legend.cex = 0.3)
dev.off()
# Vizualise detected communities
inputCommDetection_total<-CommunityStabTotal$communityOverlap
inputCommDetection_total[which(inputCommDetection_total <= .90)] <- 0
pdf(file = '../Output/Supplement/detected_communities.pdf',paper = "USr",
height = 9, width = 12)
qgraph(inputCommDetection_total, layout = "spring", theme = "Borkulo",
labels = shortnames, nodeNames = longnames, vsize=4.0,
edge.labels=FALSE, legend = TRUE, legend.cex = 0.3)
dev.off()
Totalgroup_comm <- list(
" "=c(1,2,12,20),
" "=c(3,4),
" "=c(5,8),
" "=c(6,7,21),
" "=c(9,11),
" "=c(10,22,23),
" "=c(13:19))
# define nice colors
Totalgroup_cols <- c("#BDE6F1","#E96479","#3FA796","#B4CFB0",
"#DF7861","#C3ACD0","#FFD56F")
#enables theme colorblind because we don't need to specify edge.color
inputGraphMGM <- FitW3$pairwise$wadj
signsGraphMGM <- FitW3$pairwise$signs
signsGraphMGM[which(is.na(signsGraphMGM))] <- 1
inputGraphMGM <- inputGraphMGM*signsGraphMGM
# Plot
set.seed(1)
pdf(file = '../Output/Supplement/MGM_nomin.pdf',paper = "USr", height = 9, width = 12)
GraphMGM<-qgraph(inputGraphMGM,
layout = "spring", theme = "Borkulo",
labels = shortnames, nodeNames = longnames,
cut = 0.10, maximum = 1,
details = FALSE, vsize=6.0, shape = shapes,
groups=Totalgroup_comm, color= Totalgroup_cols,
legend = TRUE, legend.cex = 0.4, borders = FALSE)
dev.off()
names(W3)
W3$pray
knitr::opts_chunk$set(echo = TRUE)
Totalgroup_comm <- list(
" "=c(1,2,12,20),
" "=c(3,4),
" "=c(5,8),
" "=c(6,7,21),
" "=c(9,11),
" "=c(10,22,23),
" "=c(13:19))
# define nice colors
Totalgroup_cols <- c("#BDE6F1","#E96479","#3FA796","#B4CFB0",
"#DF7861","#C3ACD0","#FFD56F")
#enables theme colorblind because we don't need to specify edge.color
inputGraphMGM <- FitW3$pairwise$wadj
signsGraphMGM <- FitW3$pairwise$signs
signsGraphMGM[which(is.na(signsGraphMGM))] <- 1
inputGraphMGM <- inputGraphMGM*signsGraphMGM
# Plot
set.seed(1)
pdf(file = '../Output/Supplement/MGM_nomin.pdf',paper = "USr", height = 9, width = 12)
GraphMGM<-qgraph(inputGraphMGM,
layout = "spring", theme = "Borkulo",
labels = shortnames, nodeNames = longnames,
cut = 0.10, maximum = 1,
details = FALSE, vsize=6.0, shape = shapes,
groups=Totalgroup_comm, color= Totalgroup_cols,
legend = TRUE, legend.cex = 0.4, borders = FALSE)
